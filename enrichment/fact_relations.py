"""Typed relations between RuleFacts (Phase 4)."""

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
import re
from typing import Any, Dict, Iterable, List, Optional, Set, Tuple

from .chunks import EnrichedChunk
from .rule_facts import FactType, RuleFact


class RelationType(Enum):
    """Typed edges between RuleFacts."""

    # Outcome relations (P0 - critical for failure/override traversal)
    HAS_FAILURE_MODE = "has_failure_mode"  # Success → Failure
    CONTRASTS_WITH = "contrasts_with"  # Success ↔ Failure (bidirectional)
    OVERRIDDEN_BY = "overridden_by"  # Failure → Override mechanism
    CHANGES_OUTCOME = "changes_outcome"  # Override → New result

    # Scope relations (P1 - critical for cross-chapter)
    REQUIRES_LEVEL = "requires_level"  # Fact → Level prerequisite
    APPLIES_TO_ROLE = "applies_to_role"  # Fact ↔ Fact (same role scope)

    # Semantic relations (P2 - not generated by default)
    TRIGGERS = "triggers"
    UNLESS = "unless"
    SAME_SUBJECT = "same_subject"

    # Structural relations
    IN_SAME_CLAUSE = "in_same_clause"
    IN_SAME_CHUNK = "in_same_chunk"


@dataclass
class FactRelation:
    """A typed edge between two RuleFacts."""

    relation_id: str
    relation_type: RelationType
    source_fact_id: str
    target_fact_id: str

    # Provenance
    structural_distance: int = 0
    same_clause: bool = False
    same_chunk: bool = False
    same_section: bool = False

    # Quality
    inference_method: str = "pattern"  # pattern | structural | scope | semantic
    confidence: float = 1.0

    def to_dict(self) -> Dict[str, object]:
        return {
            "relation_id": self.relation_id,
            "relation_type": self.relation_type.value,
            "source_fact_id": self.source_fact_id,
            "target_fact_id": self.target_fact_id,
            "structural_distance": self.structural_distance,
            "same_clause": self.same_clause,
            "same_chunk": self.same_chunk,
            "same_section": self.same_section,
            "inference_method": self.inference_method,
            "confidence": self.confidence,
        }


MAX_ROLE_LINKS_PER_FACT = 2
MAX_SUBJECT_LINKS_PER_FACT = 4
MAX_CHUNK_LINKS_PER_FACT = 3
STRUCTURAL_SECTION_HOPS = 2


@dataclass(frozen=True)
class _FactContext:
    fact_id: str
    clause_id: str
    chunk_id: str
    section_path: Tuple[str, ...]


def _clause_to_chunk_id(clause_id: str) -> str:
    if "::clause_" in clause_id:
        return clause_id.split("::clause_")[0]
    return clause_id


_SUBJECT_STOPWORDS = {
    "the",
    "a",
    "an",
    "your",
    "you",
    "this",
    "that",
    "of",
    "to",
    "for",
    "in",
    "on",
    "with",
}
_SUBJECT_GENERIC = {
    "entity",
    "mechanic",
    "creature",
    "creatures",
    "target",
    "targets",
    "ally",
    "allies",
    "enemy",
    "enemies",
    "character",
    "object",
    "objects",
    "item",
    "items",
}
_SUBJECT_PREFIXES = {"entity", "mechanic", "role", "trait", "condition", "outcome", "level"}


def _normalize_key(value: Optional[str]) -> str:
    return (value or "").strip().lower()


def _load_subject_titles(resolved_config: Optional[Any]) -> Set[str]:
    """Load ruleset-specific subject title terms to strip."""
    if not resolved_config:
        return set()
    det_rules = getattr(resolved_config, "deterministic_rules", None)
    if not isinstance(det_rules, dict):
        return set()
    titles = det_rules.get("subject_title_terms") or det_rules.get("subject_titles") or []
    return {str(title).strip().lower() for title in titles if str(title).strip()}


def _normalize_subject(value: Optional[str], subject_titles: Set[str]) -> str:
    text = (value or "").lower()
    text = re.sub(r"[^\w\s]", " ", text)
    tokens = [token for token in text.split() if token and token not in _SUBJECT_STOPWORDS]
    tokens = [token for token in tokens if token not in _SUBJECT_PREFIXES]
    if tokens and subject_titles and tokens[-1] in subject_titles:
        tokens = tokens[:-1]
    if tokens and all(token in _SUBJECT_GENERIC for token in tokens):
        return ""
    return " ".join(tokens)


def _parse_scope(scope: Optional[str]) -> Set[str]:
    if not scope:
        return set()
    return {part.strip().lower() for part in scope.split(";") if part.strip()}


def _structural_distance(a: Tuple[str, ...], b: Tuple[str, ...]) -> int:
    if not a or not b:
        return 0
    shared = 0
    for left, right in zip(a, b):
        if left != right:
            break
        shared += 1
    return (len(a) - shared) + (len(b) - shared)


def _build_chunk_map(chunks: Iterable[EnrichedChunk] | Dict[str, EnrichedChunk]) -> Dict[str, EnrichedChunk]:
    if isinstance(chunks, dict):
        return chunks
    return {chunk.id: chunk for chunk in chunks}


def _build_context(
    fact: RuleFact,
    chunk_map: Dict[str, EnrichedChunk],
) -> _FactContext:
    chunk_id = _clause_to_chunk_id(fact.clause_id)
    chunk = chunk_map.get(chunk_id)
    section_path = tuple(chunk.section_path) if chunk else tuple()
    return _FactContext(
        fact_id=fact.fact_id,
        clause_id=fact.clause_id,
        chunk_id=chunk_id,
        section_path=section_path,
    )


def _relation_id(source_fact_id: str, relation_type: RelationType, target_fact_id: str) -> str:
    return f"{source_fact_id}::{relation_type.value}::{target_fact_id}"


def _add_relation(
    relations: List[FactRelation],
    seen: Set[Tuple[str, str, RelationType]],
    relation_type: RelationType,
    source_fact: RuleFact,
    target_fact: RuleFact,
    source_ctx: _FactContext,
    target_ctx: _FactContext,
    inference_method: str = "pattern",
    confidence: float = 1.0,
) -> None:
    key = (source_fact.fact_id, target_fact.fact_id, relation_type)
    if key in seen:
        return

    same_clause = source_ctx.clause_id == target_ctx.clause_id
    same_chunk = source_ctx.chunk_id == target_ctx.chunk_id
    same_section = source_ctx.section_path == target_ctx.section_path and bool(source_ctx.section_path)
    structural_distance = _structural_distance(source_ctx.section_path, target_ctx.section_path)

    relations.append(
        FactRelation(
            relation_id=_relation_id(source_fact.fact_id, relation_type, target_fact.fact_id),
            relation_type=relation_type,
            source_fact_id=source_fact.fact_id,
            target_fact_id=target_fact.fact_id,
            structural_distance=structural_distance,
            same_clause=same_clause,
            same_chunk=same_chunk,
            same_section=same_section,
            inference_method=inference_method,
            confidence=confidence,
        )
    )
    seen.add(key)


def _passes_hybrid_gating(
    source_ctx: _FactContext,
    target_ctx: _FactContext,
    allow_cross_section: bool,
    shared_subject: bool,
    shared_role_scope: bool,
) -> bool:
    if source_ctx.clause_id == target_ctx.clause_id:
        return True
    if source_ctx.section_path == target_ctx.section_path and source_ctx.section_path:
        return _structural_distance(source_ctx.section_path, target_ctx.section_path) <= STRUCTURAL_SECTION_HOPS
    if not allow_cross_section:
        return False
    return shared_subject or shared_role_scope


def generate_fact_relations(
    facts: List[RuleFact],
    chunks: Iterable[EnrichedChunk] | Dict[str, EnrichedChunk],
    resolved_config: Optional[Any] = None,
    allow_cross_section: bool = True,
    include_partial: bool = False,
) -> List[FactRelation]:
    """Generate typed edges between facts using P0 + P1 relations."""
    if not facts:
        return []

    filtered = [f for f in facts if include_partial or f.is_complete]
    if not filtered:
        return []

    chunk_map = _build_chunk_map(chunks)
    contexts = {fact.fact_id: _build_context(fact, chunk_map) for fact in filtered}

    by_clause: Dict[str, List[RuleFact]] = {}
    by_role_scope: Dict[str, List[RuleFact]] = {}
    by_subject: Dict[str, List[RuleFact]] = {}
    by_chunk: Dict[str, List[RuleFact]] = {}
    subject_titles = _load_subject_titles(resolved_config)

    for fact in filtered:
        by_clause.setdefault(fact.clause_id, []).append(fact)
        for scope in _parse_scope(fact.scope):
            if scope.startswith("role:"):
                by_role_scope.setdefault(scope, []).append(fact)
        subject_key = _normalize_subject(fact.subject, subject_titles)
        if subject_key and fact.object:
            by_subject.setdefault(subject_key, []).append(fact)
        by_chunk.setdefault(contexts[fact.fact_id].chunk_id, []).append(fact)

    relations: List[FactRelation] = []
    seen: Set[Tuple[str, str, RelationType]] = set()

    # P0/P1 relations within a clause
    for clause_facts in by_clause.values():
        success = [f for f in clause_facts if f.fact_type == FactType.ON_SUCCESS]
        failure = [f for f in clause_facts if f.fact_type == FactType.ON_FAILURE]
        overrides = [
            f for f in clause_facts if f.fact_type in {FactType.OVERRIDES, FactType.INSTEAD_OF}
        ]
        level_gates = [f for f in clause_facts if f.fact_type == FactType.LEVEL_GATE]
        role_gates = [f for f in clause_facts if f.fact_type == FactType.ROLE_GATE]
        triggers = [f for f in clause_facts if f.fact_type == FactType.TRIGGERS]
        unless_facts = [f for f in clause_facts if f.fact_type == FactType.UNLESS]

        for success_fact in success:
            for failure_fact in failure:
                _add_relation(
                    relations,
                    seen,
                    RelationType.HAS_FAILURE_MODE,
                    success_fact,
                    failure_fact,
                    contexts[success_fact.fact_id],
                    contexts[failure_fact.fact_id],
                    inference_method="pattern",
                    confidence=1.0,
                )
                _add_relation(
                    relations,
                    seen,
                    RelationType.CONTRASTS_WITH,
                    success_fact,
                    failure_fact,
                    contexts[success_fact.fact_id],
                    contexts[failure_fact.fact_id],
                    inference_method="pattern",
                    confidence=1.0,
                )
                _add_relation(
                    relations,
                    seen,
                    RelationType.CONTRASTS_WITH,
                    failure_fact,
                    success_fact,
                    contexts[failure_fact.fact_id],
                    contexts[success_fact.fact_id],
                    inference_method="pattern",
                    confidence=1.0,
                )

        for failure_fact in failure:
            for override_fact in overrides:
                _add_relation(
                    relations,
                    seen,
                    RelationType.OVERRIDDEN_BY,
                    failure_fact,
                    override_fact,
                    contexts[failure_fact.fact_id],
                    contexts[override_fact.fact_id],
                    inference_method="pattern",
                    confidence=0.9,
                )

        for override_fact in overrides:
            for outcome_fact in success + failure:
                _add_relation(
                    relations,
                    seen,
                    RelationType.CHANGES_OUTCOME,
                    override_fact,
                    outcome_fact,
                    contexts[override_fact.fact_id],
                    contexts[outcome_fact.fact_id],
                    inference_method="pattern",
                    confidence=0.8,
                )

        for level_gate in level_gates:
            for fact in clause_facts:
                if fact.fact_id == level_gate.fact_id:
                    continue
                _add_relation(
                    relations,
                    seen,
                    RelationType.REQUIRES_LEVEL,
                    fact,
                    level_gate,
                    contexts[fact.fact_id],
                    contexts[level_gate.fact_id],
                    inference_method="pattern",
                    confidence=0.85,
                )

        for role_gate in role_gates:
            for fact in clause_facts:
                if fact.fact_id == role_gate.fact_id:
                    continue
                _add_relation(
                    relations,
                    seen,
                    RelationType.APPLIES_TO_ROLE,
                    fact,
                    role_gate,
                    contexts[fact.fact_id],
                    contexts[role_gate.fact_id],
                    inference_method="pattern",
                    confidence=0.85,
                )

        for trigger_fact in triggers:
            for fact in clause_facts:
                if fact.fact_id == trigger_fact.fact_id:
                    continue
                _add_relation(
                    relations,
                    seen,
                    RelationType.TRIGGERS,
                    trigger_fact,
                    fact,
                    contexts[trigger_fact.fact_id],
                    contexts[fact.fact_id],
                    inference_method="pattern",
                    confidence=0.75,
                )

        for unless_fact in unless_facts:
            for fact in clause_facts:
                if fact.fact_id == unless_fact.fact_id:
                    continue
                _add_relation(
                    relations,
                    seen,
                    RelationType.UNLESS,
                    unless_fact,
                    fact,
                    contexts[unless_fact.fact_id],
                    contexts[fact.fact_id],
                    inference_method="pattern",
                    confidence=0.75,
                )

    # Cross-section links for shared role scope
    if allow_cross_section:
        for role_scope, scope_facts in by_role_scope.items():
            ordered = sorted(scope_facts, key=lambda f: f.fact_id)
            for idx, source in enumerate(ordered):
                links = 0
                for target in ordered[idx + 1 :]:
                    source_ctx = contexts[source.fact_id]
                    target_ctx = contexts[target.fact_id]
                    if source_ctx.clause_id == target_ctx.clause_id:
                        continue
                    shared_subject = _normalize_subject(
                        source.subject, subject_titles
                    ) == _normalize_subject(target.subject, subject_titles)
                    shared_role_scope = True
                    if not _passes_hybrid_gating(
                        source_ctx,
                        target_ctx,
                        allow_cross_section=allow_cross_section,
                        shared_subject=shared_subject,
                        shared_role_scope=shared_role_scope,
                    ):
                        continue
                    _add_relation(
                        relations,
                        seen,
                        RelationType.APPLIES_TO_ROLE,
                        source,
                        target,
                        source_ctx,
                        target_ctx,
                        inference_method="scope",
                        confidence=0.6,
                    )
                    _add_relation(
                        relations,
                        seen,
                        RelationType.APPLIES_TO_ROLE,
                        target,
                        source,
                        target_ctx,
                        source_ctx,
                        inference_method="scope",
                        confidence=0.6,
                    )
                    links += 1
                    if links >= MAX_ROLE_LINKS_PER_FACT:
                        break

    # Cross-section links for shared subject (deterministic)
    for subject_key, subject_facts in by_subject.items():
        ordered = sorted(subject_facts, key=lambda f: f.fact_id)
        for idx, source in enumerate(ordered):
            links = 0
            for target in ordered[idx + 1 :]:
                source_ctx = contexts[source.fact_id]
                target_ctx = contexts[target.fact_id]
                if source_ctx.clause_id == target_ctx.clause_id:
                    continue
                shared_subject = True
                shared_role_scope = False
                if not _passes_hybrid_gating(
                    source_ctx,
                    target_ctx,
                    allow_cross_section=allow_cross_section,
                    shared_subject=shared_subject,
                    shared_role_scope=shared_role_scope,
                ):
                    continue
                _add_relation(
                    relations,
                    seen,
                    RelationType.SAME_SUBJECT,
                    source,
                    target,
                    source_ctx,
                    target_ctx,
                    inference_method="subject",
                    confidence=0.7,
                )
                _add_relation(
                    relations,
                    seen,
                    RelationType.SAME_SUBJECT,
                    target,
                    source,
                    target_ctx,
                    source_ctx,
                    inference_method="subject",
                    confidence=0.7,
                )
                links += 1
                if links >= MAX_SUBJECT_LINKS_PER_FACT:
                    break

    # Same-chunk co-occurrence (structural but fact-scoped)
    for chunk_id, chunk_facts in by_chunk.items():
        if not chunk_id or len(chunk_facts) < 2:
            continue
        ordered = sorted(chunk_facts, key=lambda f: f.fact_id)
        for idx, source in enumerate(ordered):
            links = 0
            for target in ordered[idx + 1 :]:
                source_ctx = contexts[source.fact_id]
                target_ctx = contexts[target.fact_id]
                if source_ctx.clause_id == target_ctx.clause_id:
                    continue
                _add_relation(
                    relations,
                    seen,
                    RelationType.IN_SAME_CHUNK,
                    source,
                    target,
                    source_ctx,
                    target_ctx,
                    inference_method="structural",
                    confidence=0.5,
                )
                _add_relation(
                    relations,
                    seen,
                    RelationType.IN_SAME_CHUNK,
                    target,
                    source,
                    target_ctx,
                    source_ctx,
                    inference_method="structural",
                    confidence=0.5,
                )
                links += 1
                if links >= MAX_CHUNK_LINKS_PER_FACT:
                    break

    return relations
